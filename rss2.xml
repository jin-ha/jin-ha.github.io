<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>datahack</title>
    <link>https://datahack.dev/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>datahack의 블로그</description>
    <pubDate>Mon, 12 Apr 2021 15:19:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Splunk Custom Search Command 개발 - (3)</title>
      <link>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-3/</link>
      <guid>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-3/</guid>
      <pubDate>Mon, 12 Apr 2021 15:11:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 마지막으로 &lt;code&gt;Custom Search Command&lt;/code&gt;를 좀 더 효율적으로 사용할 수 있는 방법을 공유드릴 수 있도록 하겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_time 필드&lt;/code&gt; 활용하기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time range&lt;/code&gt; 입력받기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;searchbnf&lt;/code&gt; 로 명령어 도움말 추가하기&lt;/li&gt;
&lt;li&gt;기타..&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 마지막으로 <code>Custom Search Command</code>를 좀 더 효율적으로 사용할 수 있는 방법을 공유드릴 수 있도록 하겠습니다.</p><ol><li><code>_time 필드</code> 활용하기</li><li><code>time range</code> 입력받기</li><li><code>searchbnf</code> 로 명령어 도움말 추가하기</li><li>기타..</li></ol><a id="more"></a><h1 id="time-필드-활용하기"><a href="#time-필드-활용하기" class="headerlink" title="_time 필드 활용하기"></a>_time 필드 활용하기</h1><p>앞서만든 kaggle 코드에서는 splunk event의 <a href="https://docs.splunk.com/Documentation/SplunkCloud/8.1.2101/Knowledge/Usedefaultfields">internal field</a> 중 하나인 <code>_time</code>을 단순하게 time.time()으로 인덱싱되는 시점의 <code>epoch time</code>을 넣어줬습니다.</p><p>물론 time 값이 없는 dataset일 경우에는 <code>_time</code>은 필요 없겠지만 time series data인 경우 해당 timestamp 필드를 그대로 <code>_time</code>으로 매칭시켜주면 좋습니다.</p><blockquote><p>timechart 같은 splunk 명령은 <code>_time</code>를 기반으로 동작하는데 데이터를 genereting 할때부터 잘 파싱하여 수집한다면, 추가 작업없이 <code>_time</code>을 활용할 수 있기 때문입니다.</p></blockquote><h2 id="코드-추가"><a href="#코드-추가" class="headerlink" title="코드 추가"></a>코드 추가</h2><p>각 competition의 dataset 마다 time field의 format은 제각각일 것임으로, 옵션을 주어서 사용자가 <code>동적으로 format을 입력할 수 있도록</code> 하겠습니다.</p><ol><li>추가 옵션 2개인 <code>time_field, time_format</code> 받을 수 있도록 (단, <code>require=False</code>로 필수는 아니게) 하였고,</li><li>옵션이 있을 경우에만 strptime으로 timestamp를 파싱한 후 epoch time 으로 <code>_time</code> 필드에 넣어주었습니다.</li></ol><figure class="highlight python"><figcaption><span>timestamp 파싱 부분 추가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'../lib/kaggle'</span>)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'KAGGLE_CONFIG_DIR'</span>] = os.getcwd() + <span class="string">'/../conf'</span></span><br><span class="line"><span class="keyword">from</span> kaggle.api.kaggle_api_extended <span class="keyword">import</span> KaggleApi</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> timegm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> splunklib.searchcommands <span class="keyword">import</span> dispatch, GeneratingCommand, Configuration, Option, validators</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateKaggleCommand</span><span class="params">(GeneratingCommand)</span>:</span></span><br><span class="line">    competition = Option(require=<span class="literal">True</span>)</span><br><span class="line">    data = Option(require=<span class="literal">True</span>)</span><br><span class="line">    time_field = Option(require=<span class="literal">False</span>, default=<span class="string">''</span>)</span><br><span class="line">    time_format = Option(require=<span class="literal">False</span>, default=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            api = KaggleApi()</span><br><span class="line">            api.authenticate()</span><br><span class="line">            api.competition_download_file(self.competition, self.data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> open(self.data, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">                reader = csv.DictReader(csvfile)</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">                    <span class="keyword">yield</span> self.getEvents(row)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(self.data):</span><br><span class="line">                os.remove(self.data)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEvents</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        event = result</span><br><span class="line">        <span class="keyword">if</span> self.time_field == <span class="string">''</span>:</span><br><span class="line">            event[<span class="string">'_time'</span>] = time.time()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event[<span class="string">'_time'</span>] = timegm(time.strptime(event[self.time_field], self.time_format))</span><br><span class="line">        event[<span class="string">'_raw'</span>] = json.dumps(result)</span><br><span class="line">        <span class="keyword">return</span> event</span><br><span class="line"></span><br><span class="line">dispatch(GenerateKaggleCommand, sys.argv, sys.stdin, sys.stdout, __name__)</span><br></pre></td></tr></table></figure><h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><blockquote><p>_time가 추가되면 스플렁크 검색시 이벤트탭의 시간 표시줄에도 정상적으로 표시되며, 아래 이벤트도 정상적으로 시간이 파싱되어 들어간 것을 볼 수 있습니다.<br>(epoch time은 GMT로 잘 파싱되었는데, 스플렁크 계정설정이 로컬타임존에 맞게 설정되어 +0900 으로 보임)<br><img src="kaggle_time.png" alt="_time 추가" title="_time added"></p></blockquote><blockquote><p>timechart도 정상적으로 동작함을 볼 수 있습니다. (앞 포스팅에서 설명드린대로 lookup으로 저장 후 호출 한 모습)<br><img src="kaggle_timechart.png" alt="timechart도 잘 동작" title="timechart"></p></blockquote><h1 id="time-range-입력받기"><a href="#time-range-입력받기" class="headerlink" title="time range 입력받기"></a>time range 입력받기</h1><p>어떤 <code>Custom Search Command</code> 들은 <code>time range</code>값을 사용자에게서 입력받아야 할때가 있습니다.</p><p>앞서 만든 Kaggle 명령은 굳이 사용자에게서 <code>time range</code>를 전달받을 필요가 없었습니다.<br>하지만 예를들어 제3의 Database에서 특정 <code>time range</code> 안의 데이터들만을 쿼리하여 스플렁크로 가져오는 GeneratingCommand를 만들고자 한다면 그 특정 <code>time range</code>를 사용자에게서 입력받아야 합니다.</p><p>옵션을 통해서 <code>time range</code>을 일일히 입력받을 수도 있겠지만 이는 비효율적입니다. (사용자 입장에서도 정해진 timeformat에 맞춰 일일히 입력해야해서 번거롭고, 명령어 개발하는 입장에서도 파싱이 번거럽고)</p><p>또한 다른 기본 SPL들도 공통적으로 아래의 방식으로 <code>time range</code>를 입력 받을 수 있도록 구성되어 있는데, 저희가 만드는 명령어 또한 통일시켜 주어야 사용자입장에서는 저희가 만든 command를 더 효율적으로 사용할 수 있을 것입니다.</p><blockquote><p>이 방식으로 command를 만든다면, 다른 SPL과 동일하게 다음과 같이 time range를 사용할 수 있습니다.</p><ol><li>Splunk Web UI 상의 <code>Time picker</code>를 활용할 수 있다.<br><img src="kaggle_timepicker.png" alt="Web UI상의 Time picker 모두 활용가능" title="timepicker"></li><li>Splunk REST API 로 만든 명령어 호출시 <code>earliest_time, latest_time</code> parameter도 활용 할 수 있다.<br><code>-1d@d 같은 문법도 활용 가능합니다.</code></li></ol></blockquote><p>방법은 간단합니다.<br>상속받은 각 Type의 Class에 있는 아래 속성값을 활용하면 됩니다.</p><figure class="highlight python"><figcaption><span>상속받은 class로 넘어오는 time range 값</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.search_results_info.search_et = <span class="string">'ealiest_time 이 전달되는 변수'</span></span><br><span class="line">self.search_results_info.search_lt = <span class="string">'latest_time 이 전달되는 변수'</span></span><br></pre></td></tr></table></figure><p>즉, 위 코드대로 <code>상속받은 각 Type의 Class의 해당 속성값</code>에 접근한다면 Web UI의 time picker와 REST API에서 지정한 <code>ealiest_time</code>과 <code>latest_time</code>에 손쉽게 접근할 수 있습니다.<br>값은 milliseconds가 포함된 epoch time 일텐데, 이를 사용하여 제 3의 Database에 쿼리를 시간조건을 주어 질의하는 등 활용 가능하게 됨으로 손쉽게 사용자로부터 <code>time range</code>를 입력 받을 수 있습니다.</p><h1 id="searchbnf-작성"><a href="#searchbnf-작성" class="headerlink" title="searchbnf 작성"></a>searchbnf 작성</h1><p>기본 SPL들은 아래와 같이 검색길잡이(명령어 도움말)이 잘 작성되어 있습니다.<br><img src="kaggle_searchbnf.png" alt="기본 stats 명령의 검색길잡이 내용" title="searchbnf"></p><p>저희가 만든 앱도 검색길잡이의 문구를 넣어 example 명령어와 사용법등을 제시해준다면 사용자들이 더 편하게 사용할 수 있을 것입니다.</p><blockquote><p>default/searchbnf.conf 에 아래와 같이 작성하면 됩니다.<br>적용하려면 <code>splunk 재시작 필요</code></p></blockquote><figure class="highlight plain"><figcaption><span>default/searchbnf.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[kaggle-command]</span><br><span class="line">syntax &#x3D; | kaggle COMPETITON&#x3D;&lt;competition_name&gt; DATA&#x3D;&lt;data_name&gt; [TIME_FIELD&#x3D;&lt;field&gt;] [TIME_FORMAT&#x3D;&lt;format&gt;]</span><br><span class="line">shortdesc &#x3D; kaggle dataset을 splunk로 가져옵니다. \</span><br><span class="line">    COMPETITON에 kaggle의 대회명을 DATA에 실제 csv 파일명을 입력해주세요.  (필수 파라미터)  \</span><br><span class="line">description &#x3D; time series data인 경우 TIME_FIELD에 실제 csv의 time이 있는 field명과 \</span><br><span class="line">              TIME_FORMAT에 해당 field의 포맷을 입력시 각 row의 시간값이 splunk의 _time 값이 됩니다.</span><br><span class="line">comment1 &#x3D; kaggle titanic 문제의 test.csv 파일을 가져옵니다.</span><br><span class="line">example1 &#x3D; \</span><br><span class="line">    | kaggle competition&#x3D;titanic data&#x3D;test.csv</span><br><span class="line">comment2 &#x3D; kaggle bike sharing 문제의 test.csv 파일을 datetime field를 _time 기준으로 가져옵니다.</span><br><span class="line">example2 &#x3D; \</span><br><span class="line">    | kaggle competition&#x3D;bike-sharing-demand data&#x3D;test.csv time_field&#x3D;datetime time_format&#x3D;&quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">usage &#x3D; public </span><br></pre></td></tr></table></figure><p><img src="kaggle_searchbnf2.png" alt="완성된 kaggle 검색길잡이" title="searchbnf"></p><p>그외 <a href="https://docs.splunk.com/Documentation/ITSI/4.8.1/Configure/searchbnf.conf">searchbnf.conf</a>는 alias, tags 등과 같은 옵션도 있으니 참고바랍니다.</p><h1 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h1><p>여기서는 몇가지 기억에 나는 내용을 공유드리겠습니다.</p><h2 id="run-in-preview-옵션"><a href="#run-in-preview-옵션" class="headerlink" title="run_in_preview 옵션"></a>run_in_preview 옵션</h2><p>streaming command를 만들때였는데, 스플렁크에 인덱싱된 데이터를 특정메신저로 notify해주는 명령이였습니다.<br>웹에서 만든명령을 구동 시킬 때 가끔씩 2번씩 메신저로 전송이 되는 이슈가 있었는데, 결론은 <code>commands.conf</code>의 <code>run_in_preview</code> 옵션 때문이였습니다.</p><p>디폴트 값은 True이고, 결과들을 final output 하기전에 사용자에게 preview 해주기위한 옵션입니다. 이를 False로 셋팅을 해줌으로 2번씩 명령어코드가 실행되는 것을 해결할 수 있었습니다.</p><h1 id="끝"><a href="#끝" class="headerlink" title="끝."></a>끝.</h1><p>이상 <code>Cumstom Search Command</code> 포스팅을 마치도록 하겠습니다.<br>아직 해당 기능을 활용해 보시지 않았다면, 이 포스팅이 도움이 되었으면 좋겠습니다.</p>]]></content:encoded>
      
      <comments>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Splunk Custom Search Command 개발 - (2)</title>
      <link>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-2/</link>
      <guid>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-2/</guid>
      <pubDate>Mon, 12 Apr 2021 15:11:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 &lt;code&gt;Splunk Custom Search Command&lt;/code&gt; 를 이용하여 실제 Kaggle 에서 Dataset 을 Splunk 로 가져오는 앱을 만들어 보겠습니다.&lt;/p&gt;
&lt;p&gt;미리 완성될 Kaggle SPL의 옵션값들을 떠올려 보는것이 만들어 나갈 코드를 어떤식으로 개발할지 방향성을 잡기에 쉽습니다.&lt;/p&gt;
&lt;p&gt;아마 Kaggle 앱은 아래와 같이 동작하면 좋을것 같습니다.&lt;br&gt;&lt;code&gt;| kaggle competition=&amp;quot;titanic&amp;quot; data=&amp;quot;train.csv&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;또한 불러올 데이터셋이 time series 데이터일 경우를 대비하여,&lt;br&gt;&lt;code&gt;time_field=&amp;quot;create_time&amp;quot; time_format=&amp;quot;%Y/%m/%d %H:%M:%S&amp;quot;&lt;/code&gt;&lt;br&gt;라는 필드도 옵션으로 넣어줄 수 있게 만들어 주면 좋을 것 같네요.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 <code>Splunk Custom Search Command</code> 를 이용하여 실제 Kaggle 에서 Dataset 을 Splunk 로 가져오는 앱을 만들어 보겠습니다.</p><p>미리 완성될 Kaggle SPL의 옵션값들을 떠올려 보는것이 만들어 나갈 코드를 어떤식으로 개발할지 방향성을 잡기에 쉽습니다.</p><p>아마 Kaggle 앱은 아래와 같이 동작하면 좋을것 같습니다.<br><code>| kaggle competition=&quot;titanic&quot; data=&quot;train.csv&quot;</code></p><p>또한 불러올 데이터셋이 time series 데이터일 경우를 대비하여,<br><code>time_field=&quot;create_time&quot; time_format=&quot;%Y/%m/%d %H:%M:%S&quot;</code><br>라는 필드도 옵션으로 넣어줄 수 있게 만들어 주면 좋을 것 같네요.</p><a id="more"></a><h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>데이터분석 공부와 Kaggle 도전도 목표에 있고, 만들어두면 언젠가(?) 도움이 될듯하여 그리고 GeneratingCommand에 적합한 예제가 될듯하여 이 앱을 만들어 보기로 했습니다.</p><p>앞선 포스팅에서 설명드린 protocol 중 v2 protocol을 이용하여 만들어 볼 예정입니다.</p><blockquote><p>간단한 명령어는 v1 protocol로 만들어도 되긴 하는데, 이전 버전의 라이브러리라 그런지 부족한 부분들이 꽤 있습니다. (v1에서 기본으로 제공해주는 getKeywordsAndOptions 함수는 v1 commands 를 실행 시 넘어오는 keyword 와 option을 파싱해줘야 하는데 제대로 파싱이 안됩니다…)</p></blockquote><h1 id="kaggle-API-확인"><a href="#kaggle-API-확인" class="headerlink" title="kaggle API 확인"></a>kaggle API 확인</h1><p>먼저 kaggle API 동작방식을 이해해야 python 코드로 구현할 수 있습니다.</p><p><a href="https://www.kaggle.com/docs/api">Kaggle API Documents</a>에는 pip으로 다운받은 kaggle 명령을 cli 에서 실행시켜서 (<code>kaggle datasets download -d [DATASET]</code>) 데이터셋을 다운을 받는데, 저희는 파이썬 코드상에서 SDK를 이용하여 다운 받고자 합니다.</p><p>Kaggle API의 github을 찾아보니, 다음과 같은 코드와 주석을 찾았습니다.</p><figure class="highlight python"><figcaption><span>https://github.com/Kaggle/kaggle-api/blob/master/kaggle/api/kaggle_api_extended.py</span><a href="https://github.com/Kaggle/kaggle-api/blob/master/kaggle/api/kaggle_api_extended.py">kaggle-api_링크</a></figcaption><table><tr><td class="gutter"><pre><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">config_dir = os.environ.get(<span class="string">'KAGGLE_CONFIG_DIR'</span>) <span class="keyword">or</span> os.path.join(</span><br><span class="line">    expanduser(<span class="string">'~'</span>), <span class="string">'.kaggle'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(config_dir):</span><br><span class="line">    os.makedirs(config_dir)</span><br><span class="line"></span><br><span class="line">config_file = <span class="string">'kaggle.json'</span></span><br><span class="line">config = os.path.join(config_dir, config_file)</span><br><span class="line">config_values = &#123;&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""authenticate the user with the Kaggle API. This method will generate</span></span><br><span class="line"><span class="string">       a configuration, first checking the environment for credential</span></span><br><span class="line"><span class="string">       variables, and falling back to looking for the .kaggle/kaggle.json</span></span><br><span class="line"><span class="string">       configuration file.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> os.environ.items():</span><br><span class="line">    <span class="keyword">if</span> key.startswith(<span class="string">'KAGGLE_'</span>):</span><br><span class="line">        config_key = key.replace(<span class="string">'KAGGLE_'</span>, <span class="string">''</span>, <span class="number">1</span>).lower()</span><br><span class="line">        config_data[config_key] = val</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>코드를 훑어본 결과 Kaggle SDK 호출하기 위해서는 먼저 인증 단계(<code>authenticate function</code>)가 이루어 져야 하는데,</p><ol><li><code>KAGGLE_</code> 로 시작하는 환경변수에 kaggle.json의 path를 지정 하여 인증하거나</li><li><code>~/.kaggle/kaggle.json</code> 의 파일을 바로 인증</li></ol><p>둘 중 하나의 방식으로 인증을 해야 하는 것을 알았습니다.<br>2번 방식을 사용하기에는 스플렁크앱이 어떤 사용자로 구동 되는지 실제 환경마다 다를것이기 때문에 저희는 1번 방식인 environment을 통해 인증을 진행하는 방식으로 kaggle 코드를 작성해 보겠습니다.</p><h2 id="kaggle-json-다운로드"><a href="#kaggle-json-다운로드" class="headerlink" title="kaggle.json 다운로드"></a>kaggle.json 다운로드</h2><p>먼저 kaggle 홈에서 자신의 api key 정보를 다운로드 합니다.</p><p><img src="kaggle_token_download.png" alt="[Kaggle 홈페이지 로그인] - [본인 프로필 사진 클릭] - [Account] - [API] - [Create New API Token]" title="kaggle api token download"></p><p>다운받은 <code>kaggle.json</code> 파일은 단순 text 파일로 자신의 계정 및 API token이 json 형태로 작성되어 있습니다.</p><p>해당 파일을 일단 앞선 포스팅에서 만든 Splunk App 경로에 conf 라는 디렉토리를 추가하여 저장합니다.</p><h1 id="App-셋팅"><a href="#App-셋팅" class="headerlink" title="App 셋팅"></a>App 셋팅</h1><p>앞선 포스팅의 <code>App 구조</code>에서 설명한대로 작성한다면 <code>conf 와 lib</code> 디렉토리는 없지만 이 두 디렉토리는 명령어를 관리함에 있어서 명령어별로 Python library 및 config 들을 관리하기 위한 디렉토리라고 보시면 됩니다. </p><blockquote><ol><li>conf 디렉토리 : 명령어별로 사용되는 설정값이 저장될 디렉토리</li><li>lib 디렉토리 : 명령어별로 사용되는 python library 가 저장될 디렉토리</li></ol><p><code>이 디렉토리들은 필수디렉토리는 아닙니다. 한 앱에서 여러 Custom Search Command를 효율적으로 관리하기 위해 각 명령어별로 python library 경로와 설정값들을 분리시켜 저장시키는 공간이라고 보시면 됩니다.</code></p></blockquote><p>앞선 포스팅의 기본 디렉토리에 conf, lib 디렉토리가 추가된 App 구조는 다음과 같아 집니다.<br><img src="Kaggle_dataset_struct.png" alt="`KAGGLE_DATASET` 이라는 이름의 앱으로 생성한 저의 App 디렉토리 구조" title="kaggle app struct"></p><ol><li><code>conf/kaggle.json</code> : Kaggle에서 다운받은 API token 파일</li><li><code>default/commands.conf</code> : [kaggle] stanza를 추가한 설정 파일</li><li><code>bin/my_kaggle.py</code> : 우리가 실제로 작성해야할 Python code</li></ol><h2 id="library-및-conf-셋팅"><a href="#library-및-conf-셋팅" class="headerlink" title="library 및 conf 셋팅"></a>library 및 conf 셋팅</h2><p>저희는 <code>bin/my_kaggle.py</code> 에서 kaggle 모듈을 import 해야 합니다.<br>(+ Custom Search Command 개발에는 splunk-sdk도 필요 합니다.)</p><h3 id="python-library-관리"><a href="#python-library-관리" class="headerlink" title="python library 관리"></a>python library 관리</h3><blockquote><p><code>Custom Search Command</code> 앱을 몇개 만들어 보면서 pip 으로 다운받는 라이브러리들을 여러방식으로 관리해봤지만, 이 방식이 가장 깔끔했습니다.</p><p>각 명령어별로 <code>lib/[my_command]/</code> 디렉토리를 만들고 해당 경로에 requirements.txt 를 관리하여 각각 library를 다운로드 받고, 각 <code>bin/[my_command]</code> 의 코드 최초에 해당 디렉토리를 sys.path로 등록</p><footer><strong>Custom Search Command 파이썬 라이브러리 깔끔하게 관리하기</strong></footer></blockquote><p>저희는 <code>kaggle 1.5.12</code> 버전과 <code>splunk-sdk 1.6.14</code>을 사용할 예정이라, requirements.txt 에 버전을 작성하고<br><code>pip3 install -r requirements.txt --target=$SPLUNK_HOME/etc/apps/kaggle_dataset/lib/kaggle/.</code> 을 실행하여 아래와 같이 해당 –target 디렉토리에 kaggle 및 splunk-sdk와 dependency 라이브러리들을 다운받습니다.</p><p><img src="kaggle_lib_structure.png" alt="Custom Search Command 파이썬 라이브러리 깔끔하게 관리하기" title="library path"></p><h3 id="conf-관리"><a href="#conf-관리" class="headerlink" title="conf 관리"></a>conf 관리</h3><p>또한 명령어별로 config 값들을 관리할 필요가 자주있는데, 이번 경우에는 Kaggle 사이트에서 다운받은 토큰파일인 <code>kaggle.json</code> 파일입니다. 해당 파일을 conf 디렉토리에 위치 시켜줍니다.</p><h1 id="실제코드"><a href="#실제코드" class="headerlink" title="실제코드"></a>실제코드</h1><p>코드는 먼저</p><ol><li>requirement 들을 다운받은 library 경로를 <code>sys.path</code>로 등록시켜주고,</li><li>위에서 kaggle github 코드를 분석한대로 authenticate가 구동되게 하기 위해 <code>kaggle.json</code>파일이 있는 conf 디렉토리를 <code>os.environ[&#39;KAGGLE_CONFIG_DIR&#39;]</code>에 등록시켜주면 됩니다.</li></ol><p>즉, 이번 my_kaggle.py의 코드는 아래와 같이 시작이 됩니다.</p><figure class="highlight python"><figcaption><span>bin/my_kaggle.py 의 시작코드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'../lib/kaggle'</span>)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'KAGGLE_CONFIG_DIR'</span>] = os.getcwd() + <span class="string">'/../conf'</span></span><br><span class="line"><span class="keyword">from</span> kaggle.api.kaggle_api_extended <span class="keyword">import</span> KaggleApi</span><br></pre></td></tr></table></figure><h2 id="예제-GeneratingCommand-코드"><a href="#예제-GeneratingCommand-코드" class="headerlink" title="예제 GeneratingCommand 코드"></a>예제 GeneratingCommand 코드</h2><p>먼저 실제 어떤식으로 동작하는지 직접 보기위해 단순한 GeneratingCommand 을 만들어 실행 시켜 보겠습니다.</p><figure class="highlight python"><figcaption><span>예제코드 bin/my_kaggle.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'../lib/kaggle'</span>)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'KAGGLE_CONFIG_DIR'</span>] = os.getcwd() + <span class="string">'/../conf'</span></span><br><span class="line"><span class="keyword">from</span> kaggle.api.kaggle_api_extended <span class="keyword">import</span> KaggleApi</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> splunklib.searchcommands <span class="keyword">import</span> dispatch, GeneratingCommand, Configuration, Option, validators</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateKaggleCommand</span><span class="params">(GeneratingCommand)</span>:</span></span><br><span class="line">    foo = Option(require=<span class="literal">False</span>, default=<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">yield</span> self.getEvents(&#123;<span class="string">'foo'</span>:self.foo + str(i)&#125;)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEvents</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        event = result</span><br><span class="line">        event[<span class="string">'_time'</span>] = time.time()</span><br><span class="line">        event[<span class="string">'_raw'</span>] = json.dumps(result)</span><br><span class="line">        <span class="keyword">return</span> event</span><br><span class="line"></span><br><span class="line">dispatch(GenerateKaggleCommand, sys.argv, sys.stdin, sys.stdout, __name__)</span><br></pre></td></tr></table></figure><p>bin/my_kaggle.py을 위와같이 작성 한뒤 splunk 재시작 후 <code>| kaggle</code>을 실행시켜 봅니다.<br>(최초 명령어를 셋팅할때만 splunk 재시작이 필요합니다. 이후 코드 수정시 재시작 불필요.)</p><blockquote><p>만든 앱의 명령을 다른 앱에서도 실행시키기 위해서는, 권한설정을 해줘야 합니다.<br><img src="kaggle_app_role.png" alt="앱 권한 부여" title="App role setting"></p></blockquote><p><img src="kaggle_execute.gif" alt="예제 GeneratingCommand 동작모습" title="kaggle splunk command"></p><p>코드는 간단합니다, 앞선 포스팅에서 설명드린대로 <code>GeneratingCommand</code> 을 상속받아 여기서는 <code>generate라는 function만 정의해주면 되고</code>, <code>yield 처리된 값이 Splunk의 event가 됩니다</code>.</p><p>yield 를 json 형태로 넘기면 그대로 json의 key 값이 스플렁크의 필드명, json의 value 값이 해당 필드의 값이 됩니다. 여기서는 getEvent라는 함수를 추가하여 Splunk의 internal field(_time, _raw) 들을 채워주도록 하였습니다.</p><blockquote><p>각 type별 상세설명은 <a href="https://docs.splunk.com/DocumentationStatic/PythonSDK/1.6.13/searchcommands.html#splunklib.searchcommands.GeneratingCommand">여기 docs</a>에서 확인 가능하며, 이 <a href="https://github.com/splunk/splunk-sdk-python/tree/master/examples/searchcommands_app/package/bin">공식 example code 들</a>을 보는 것도 도움이 되었습니다.</p><p>Option도 직관적이지만 <a href="https://docs.splunk.com/DocumentationStatic/PythonSDK/1.6.13/searchcommands.html#splunklib.searchcommands.Configuration">Configuration Class</a>와 <a href="https://docs.splunk.com/DocumentationStatic/PythonSDK/1.6.13/searchcommands.html#splunklib.searchcommands.Option">Option Class</a>을 참조하시면 도움이 됩니다.</p></blockquote><h2 id="실제-my-kaggle-py-작성하기"><a href="#실제-my-kaggle-py-작성하기" class="headerlink" title="실제 my_kaggle.py 작성하기"></a>실제 my_kaggle.py 작성하기</h2><p>이제 우리가 할일은 Option 클래스로 필요한 옵션값(명령어 인자값)들을 받고, Generete 함수안에서 Kaggle 모듈을 이용해 필요한 Dataset만 가져와 yield 처리 해주면 됩니다.</p><p>코드 전체를 설명하지는 않겠습니다. 만들어진 코드는 아래와 같습니다.</p><figure class="highlight python"><figcaption><span>완성된 bin/my_kaggle.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'../lib/kaggle'</span>)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'KAGGLE_CONFIG_DIR'</span>] = os.getcwd() + <span class="string">'/../conf'</span></span><br><span class="line"><span class="keyword">from</span> kaggle.api.kaggle_api_extended <span class="keyword">import</span> KaggleApi</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> splunklib.searchcommands <span class="keyword">import</span> dispatch, GeneratingCommand, Configuration, Option, validators</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateKaggleCommand</span><span class="params">(GeneratingCommand)</span>:</span></span><br><span class="line">    competition = Option(require=<span class="literal">True</span>)</span><br><span class="line">    data = Option(require=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            api = KaggleApi()</span><br><span class="line">            api.authenticate()</span><br><span class="line">            api.competition_download_file(self.competition, self.data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> open(self.data, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">                reader = csv.DictReader(csvfile)</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">                    <span class="keyword">yield</span> self.getEvents(row)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(self.data):</span><br><span class="line">                os.remove(self.data)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEvents</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        event = result</span><br><span class="line">        event[<span class="string">'_time'</span>] = time.time()</span><br><span class="line">        event[<span class="string">'_raw'</span>] = json.dumps(result)</span><br><span class="line">        <span class="keyword">return</span> event</span><br><span class="line"></span><br><span class="line">dispatch(GenerateKaggleCommand, sys.argv, sys.stdin, sys.stdout, __name__)</span><br></pre></td></tr></table></figure><p><a href="https://docs.splunk.com/DocumentationStatic/PythonSDK/1.6.13/searchcommands.html#splunklib.searchcommands.Option">Option Class</a>으로 저희가 본 포스팅 시작할때 구상한 옵션값들 <code>competition, data</code>을 필수로 사용자가 입력하도록 합니다.</p><p><code>require=True</code>의 옵션일 경우 사용자가 해당 옵션값들을 미입력시 에러처리를 아래와 같이 제공해줍니다.<br><img src="no_option_error.png" alt="require=True 옵션값 미입력시" title="require error"></p><p>generate 함수안에서는 kaggle API의 <code>competition_download_file</code> 을 이용하여 옵션값으로 전달받은 competition 이름과 dataset 이름으로 대상 csv 파일을 다운받아, json 형식으로 읽은 후 yield 처리 해주기만 하면 됩니다.<br>(competition_download_file 함수는 파일을 current directory에 파일을 다운로드 하기 떄문에, 삭제하는 코드도 넣어줬습니다.)</p><h2 id="완성된-kaggle-명령어"><a href="#완성된-kaggle-명령어" class="headerlink" title="완성된 kaggle 명령어"></a>완성된 kaggle 명령어</h2><p>완성된 kaggle 명령은 아래와 같이 동작합니다.</p><p><img src="kaggle_titanic.gif" alt="titanic 문제의 test.csv 데이터 수집 및 추가 파이프(stats) 명령" title="kaggle with stats"></p><p>competition 옵션값으로 넘겨줄 값은 실제 Kaggle 웹사이트의 다운받을 competition 링크로 들어가 data 탭을 눌러 아래그림의 1에 있는 부분을 넣어주면 되고, data 옵션값은 실제 csv 파일명(아래그림의 2)을 넘겨주면 됩니다.</p><p>그리고 kaggle API github page에 아래와 같은 안내글이 있었네요..<br><code>Note: you will need to accept competition rules at https://www.kaggle.com/c/&lt;competition-name&gt;/rules</code><br>각 competition 별로 있는 rules는 꼭 페이지에서 accept 해줘야 합니다.. API 상에 accept하는 함수가 있는지 찾아봤는데 안보이네요.</p><p><img src="kaggle_accept_rule.png" alt="competition별로 다운받기 전 웹상에서 accept 해줘야함" title="accept kaggle rule"></p><blockquote><p>아마 dataset 중 csv가 아닌 json도 있을 것입니다. 이는 옵션값 <code>[type=csv|json]</code>으로 코드상에서 해당 타입을 처리해주는 분기부분만 추가하면 될것 같은데, 필요하신분은 추가 개발을 해보시길 바랍니다.</p></blockquote><blockquote><p>지금은 해당 명령을 수행할 때 마다 kaggle API을 이용하여 <code>다운로드</code>를 수행하게됩니다.<br>매번 명령을 수행할때 마다 <code>다운로드</code> 받아서 splunk에 밀어넣는 작업은 비효율적임으로, 이런 데이터들은 outputlookup을 통해 한번 가져 온 이후 그 다음부터는 API 호출없이 inputlookup을 통해 바로 이미 가져온 데이터를 사용하는게 효율적일 것입니다.<br><img src="kaggle_to_lookup.gif" alt="kaggle 명령과 함께 모든 SPL 파이프라인 활용가능" title="kaggle input to lookup"></p><p>앞서 설명드렸듯이 이미 Custom Search Command로 가져온 데이터들은 모든 SPL을 활용 가능합니다. (outputlookup, collect, stats 등등)</p></blockquote><h1 id="끝"><a href="#끝" class="headerlink" title="끝."></a>끝.</h1><p>이상으로 kaggle 에서 dataset을 다운받아오는 GeneretingCommand를 만들어봤습니다.</p><p>다음 포스팅에서는 이 kaggle 명령을 time이 있는 데이터셋을 가져올 수 있도록 변경해보고 몇가지 팁들을 작성하도록 하겠습니다.</p>]]></content:encoded>
      
      <comments>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Splunk Custom Search Command 개발 - (1)</title>
      <link>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-1/</link>
      <guid>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-1/</guid>
      <pubDate>Mon, 12 Apr 2021 15:11:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;Splunk 를 사용하면서 큰 장점 중 하나로 생각했던, &lt;code&gt;Custom Search Command&lt;/code&gt; 에 대해 포스팅하고자 합니다.&lt;/p&gt;
&lt;p&gt;해당 기능을 통해서는 아래와 같은 스플렁크 앱 개발은 물론 다양한 아이디어 적용이 가능합니다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Custom Search Command로 개발가능한 Splunk 앱의 예시&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. ElasticSearch API를 이용하여 ES의 Data를 Splunk로 Integration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   (가져온 Data는 Splunk search-head 메모리에 올라왔기 때문에 stats 등 SPL은 물론 경보 및 레포트등 스플렁크 기능 활용 가능)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. Splunk 에 인덱싱된 Data를 내가만든 명령어 SPL으로 Streaming하여 원하는곳으로 전송&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 등등.. Python 코드로 작성가능한 모든것 (Splunk 로 가져오거나, 내보내거나.)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;이번 포스팅은 아래와 같이 3개의 주제로 나눠서 게시될 예정입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Custom Search Command 란? - &lt;code&gt;이번 게시물&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Kaggle dataset download 앱 개발해보기&lt;/li&gt;
&lt;li&gt;Event별 _time 관리 / time range 입력받기 / 명령어 도움말 관리&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Splunk 를 사용하면서 큰 장점 중 하나로 생각했던, <code>Custom Search Command</code> 에 대해 포스팅하고자 합니다.</p><p>해당 기능을 통해서는 아래와 같은 스플렁크 앱 개발은 물론 다양한 아이디어 적용이 가능합니다.</p><figure class="highlight plain"><figcaption><span>Custom Search Command로 개발가능한 Splunk 앱의 예시</span></figcaption><table><tr><td class="code"><pre><span class="line">1. ElasticSearch API를 이용하여 ES의 Data를 Splunk로 Integration</span><br><span class="line">   (가져온 Data는 Splunk search-head 메모리에 올라왔기 때문에 stats 등 SPL은 물론 경보 및 레포트등 스플렁크 기능 활용 가능)</span><br><span class="line">2. Splunk 에 인덱싱된 Data를 내가만든 명령어 SPL으로 Streaming하여 원하는곳으로 전송</span><br><span class="line">3. 등등.. Python 코드로 작성가능한 모든것 (Splunk 로 가져오거나, 내보내거나.)</span><br></pre></td></tr></table></figure><p>이번 포스팅은 아래와 같이 3개의 주제로 나눠서 게시될 예정입니다.</p><ol><li>Custom Search Command 란? - <code>이번 게시물</code></li><li>Kaggle dataset download 앱 개발해보기</li><li>Event별 _time 관리 / time range 입력받기 / 명령어 도움말 관리</li></ol><a id="more"></a><h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>저는 업무에서 다양한 <code>Custom Search Command</code> 을 만들어봤었습니다.<br>제일 처음 만들어봤던 앱은 예시 1의 내용인 <code>ElasticSearch API를 이용하여 ES의 Data를 Splunk로 Integration</code> 하는 Command 였었습니다.</p><blockquote><p>당시 저는 Splunk 의 라이센스 부족에 힘들어 하며…<br>ElasticSearch로 부족한 인덱싱을 메우고 있었습니다.</p><p>하지만, 생각보다 ElasticSearch의 Alert 기능이나 실제 로그를 검색하는 사용자들의 Web UI 편의성 (Kibana.. Lucene.. Aggregation을 위해서는 DSL 까지..)이 떨어져서 고민을 하고있었는데, 그에 딱 들어맞는 해결책이 <code>Splunk Custom Search Command</code> 였습니다.</p><p>앱 개발을 통해 ElasticSearch에 (무료로) Indexing 된 데이터를 스플렁크로 고스란히 가져와 스플렁크의 강력한 통계 SPL들은 물론 모두 사용할 수 있었고 Dashboard 와 Alert 기능등도 활용하며, 필요하다면 특정 로그들은 스플렁크 summary index로 다시 collect 할수도 있었습니다.</p><footer><strong>늘어나는 로그량에 비해 부족한 Splunk 라이센스에 힘들어하던 Splunk 담당자...</strong></footer></blockquote><p>일단 하나를 만들어보니 그 이후로는 필요한 명령어들은 쉽게 만들 수 있었습니다.<br>스플렁크 <code>기본기능으로는 힘든 문제도 Custom Search Command의 개발로 간단하게 해결</code>할 수도 있었습니다.</p><figure class="highlight plain"><figcaption><span>아래와 같은 문제들을 해결 가능</span></figcaption><table><tr><td class="code"><pre><span class="line">DB Connector(DBX)에 mongoDB 기능은 포함되어 있지않아서 mongoDB로 Splunk 데이터를 밀어넣는 앱을 개발한다거나,</span><br><span class="line">Slack 등 글로벌앱은 splunkbase에 잘 있지만 국내 메신저는 없어서 앱개발을 통해 간단히 Splunk 경보를 국내 메신저로 Notify 한다거나.</span><br><span class="line">스케쥴링에 의해 돌아가는 특정 검색조건의 결과 로그들에 한해서만 제 3의 저장소(Qradar)로 원하는 형식으로 전송한다거나.</span><br><span class="line">...등</span><br></pre></td></tr></table></figure><p>Splunk는 <a href="https://docs.splunk.com/">docs</a> 와 <a href="https://community.splunk.com/">community</a> 가 잘 되어있기는 하지만, 그 당시 <code>Custom Search Command</code>는 비교적 부족한 부분도 있었던거 같습니다..<br>(특히 App별 Python Package 관리 및 _time, _raw 등 internal field에 대한 정의의 설명 부족)</p><p>이 글은 보시는 분들도 아직 <code>Custom Search Command</code>를 개발해 사용해보시지 않았다면, 이 기능을 통해 더 넓은 Splunk의 활용에 도움이 되었으면 좋겠습니다.</p><h1 id="Custom-Search-Command-란"><a href="#Custom-Search-Command-란" class="headerlink" title="Custom Search Command 란?"></a>Custom Search Command 란?</h1><h2 id="v1과-v2의-차이"><a href="#v1과-v2의-차이" class="headerlink" title="v1과 v2의 차이"></a>v1과 v2의 차이</h2><p><code>Custom Searach Command</code>의 버전은 <code>v1 protocol</code>과 <code>v2 protocol</code>가 있습니다.<br>단순하게 v1은 기존 버전 v2 개선된 버전이라고 보시면 됩니다.<br>차이는 아래와 같습니다.</p><h3 id="v1-protocol"><a href="#v1-protocol" class="headerlink" title="v1 protocol"></a>v1 protocol</h3><p>초창기 버전, intersplunk.py 라는 이전 SDK 를 통해 개발합니다.<br><code>Splunk 3.0 이후</code> 부터 사용 가능합니다.<br>대용량 데이터 처리를 위해서는 v2가 더 효율적입니다.<br>python 에 대해서만 지원하고,<br>간단한 명령어를 만들기에 적합합니다.</p><h3 id="v2-protocol"><a href="#v2-protocol" class="headerlink" title="v2 protocol"></a>v2 protocol</h3><p><code>Splunk 6.3 이후</code> 부터 사용 가능합니다.<br>대용량 데이터 처리에 있어 v1 보다 runtime 오버헤드가 크게 줄어들었다고 합니다.<br>python 뿐만 아니라, Go, java, C++ 도 지원 한다고 합니다. (저는 파이썬으로만 개발해봐서 상세 내용은 모르겠네요.)<br>v2의 경우 <code>아래의 4가지의 타입의 Splunk 명령어를 미리 인터페이스화</code> 해놨습니다.<br>즉, 4가지 중 만들고자 하는 타입의 Class 를 상속받아 구현하면 됩니다.</p><table><thead><tr><th align="center">Command Type</th><th align="center">Command Examples</th></tr></thead><tbody><tr><td align="center">GeneratingCommand</td><td align="center">makeresults, inputlookup, inputcsv…</td></tr><tr><td align="center">StreamingCommand</td><td align="center">eval, fields, rename, where…</td></tr><tr><td align="center">ReportingCommand</td><td align="center">chart, timechart, stats, top…</td></tr><tr><td align="center">EventingCommand</td><td align="center">sort, dedup…</td></tr></tbody></table><blockquote><p>각 타입에 매칭되는 SPL의 기본 <code>Command Examples</code>을 보시면, 각 타입이 어떤 역할을 하는 Command 인지 이해하시기 쉬우실 것 같습니다.</p><p>Genarating : 말그대로 events 를 생성하고자 할때 사용합니다. <code>항상 SPL의 최초 파이프라인에서 실행되어야 합니다.</code><br>Streaming : events들을 one-by-one 으로 처리(변환 등)를 하고자 할때 사용합니다.<br>Repoting : Data table 형태로 만들어주고자 할때 사용합니다.<br>Eventing : Data set가 필요하며, 변환등이 아닌 odering과 같은 처리를 하고자 할때 사용합니다.</p><p>내가 만들고자 하는 앱이 어떤 Type에 적합한지 확인하고,<br>거기에 맞는 Class를 상속받아 실제 코드를 구현하기만 하면 됩니다.</p></blockquote><p>또한 <a href="https://docs.splunk.com/DocumentationStatic/PythonSDK/1.6.13/searchcommands.html#splunklib.searchcommands.Configuration">Configuration Class</a>와 <a href="https://docs.splunk.com/DocumentationStatic/PythonSDK/1.6.13/searchcommands.html#splunklib.searchcommands.Option">Option Class</a>도 제공해주는데, 이는 위와 같은 Commands를 만들다 보면 추가적인 설정이 필요해짐을 느낄때 찾아보시면 될것 같습니다. (ex, Streaming Command 를 만드는데 특정 변수를 각 indexer 끼리 shared 하고자 할때 Congifuration 어노테이션에 local=True)</p><h2 id="App"><a href="#App" class="headerlink" title="App"></a>App</h2><p>App 은 Dashboard, Alert, Command 등을 포함할 수 있습니다.<br>저희가 만들 <code>Custom Search Command</code> 는 이 중 Command 부분입니다.<br>Splunkbase 등에서 앱을 설치하면 특정 SPL Command가 생기듯이, 저희는 App 구조안에 Command 만 만들어 볼 예정 입니다.</p><p><code>Custom Search Command</code> 을 몇개 만들면서 사용해본 결과 하나의 App 안에 필요한 Command 등을 몰아넣고 배포하고 관리하는것이 더 편리하였습니다.</p><blockquote><p>하나의 앱 안에 여러 <code>Custom search command</code> 들을 개발하고 관리하는 기준으로 설명하도록 하겠습니다.</p></blockquote><h3 id="App-생성"><a href="#App-생성" class="headerlink" title="App 생성"></a>App 생성</h3><p>일단 빈 App을 하나 생성해보겠습니다.<br>[Splunk] - [앱 관리] - [앱 만들기] - [기본적인 앱 이름 등 설정 후 템플릿은 <code>barebones</code>으로 만듭니다]</p><blockquote><p>$SPLUNK_HOME/etc/app/<br>하단에 위에서 생성한 빈 App 이 생성 됩니다.<br>저는 Mac 환경에 Test App 이라는 앱을 생성했습니다.</p></blockquote><h3 id="App-구조"><a href="#App-구조" class="headerlink" title="App 구조"></a>App 구조</h3><p>생성된 빈 <code>Test App</code>의 구조는 아래와 같이 되어있습니다.<br><img src="splunk-test-app-tree.png" alt="" title="생성되는 앱 구조"></p><p>생성해야할 파일은 아래와 같습니다.</p><ol><li>bin/“각 명령어 python 파일”<blockquote><p>위에서 설명한 Type에 맞는 클래스를 상속받아 구현해야할 Python 코드입니다.</p></blockquote></li><li><a href="https://docs.splunk.com/Documentation/ITSI/4.8.1/Configure/commands.conf">default/commands.conf</a><blockquote><p>[mycommand]<br>filename = mycommand.py<br>python.version = python3<br>chunked = true</p><p>[mycommand] stanza가 SPL에서 사용된 명령어의 이름입니다. 즉 이렇게 작성하면 스플렁크에서 <code>mycommand</code>라는 명령어가 만들어지고, 이는 bin의 mycommand.py를 구동시켜 동작하게 됩니다.</p><p>한 App 안에 여러 명령어를 만들고 싶다면 [command] stanza를 이 파일에 추가해주면 됩니다.</p><p>python 코드자체에 v1, v2을 체크하는 부분이 없기 때문에, commands.conf의 각 명령어 stanza에 chucked를 통해 v1과 v2를 정의해줘야 합니다. <code>chunked = true 일 경우 v2 protocol</code> 의 custom search command 입니다.</p></blockquote></li><li>(옵션) default/searchbnf.conf<blockquote><p>searchbnf.conf는 명령어의 사용법이나 example query등을 작성하여, Splunk 검색 길잡이에 표시되게 하는 설정 입니다. 잘 활용하면 사용자 편의성을 높일 수 있습니다.<br>3번째 Tip 포스팅에서 자세한 내용을 다루도록 하겠습니다.</p></blockquote></li></ol><p>다음 포스팅에서는 바로 실제 캐글의 데이터셋을 손쉽게 다운 받을 수 있는 <code>Generating Custom Search Command</code>를 만들어보겠습니다.</p>]]></content:encoded>
      
      <comments>https://datahack.dev/2021/04/13/data/splunk/custom-search-command-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Logstash Java filter plugin 개발</title>
      <link>https://datahack.dev/2021/03/11/data/elastic/logstash-java-filter-plugin/</link>
      <guid>https://datahack.dev/2021/03/11/data/elastic/logstash-java-filter-plugin/</guid>
      <pubDate>Thu, 11 Mar 2021 12:26:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;Elastic 공식 Docs의 &lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/java-filter-plugin.html#java-filter-plugin&quot;&gt;How to write a Java filter plugin&lt;/a&gt; 에 잘 나와있지만,&lt;br&gt;내용대로 진행시 몇가지 에러가 발생했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FAILURE: Build failed with an exception&lt;/li&gt;
&lt;li&gt;error: package co.elastic.logstash.api does not exist&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;으로 검색하여 들어오신 분에게 도움이 되었으면 합니다!&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Elastic 공식 Docs의 <a href="https://www.elastic.co/guide/en/logstash/current/java-filter-plugin.html#java-filter-plugin">How to write a Java filter plugin</a> 에 잘 나와있지만,<br>내용대로 진행시 몇가지 에러가 발생했다.</p><ul><li>FAILURE: Build failed with an exception</li><li>error: package co.elastic.logstash.api does not exist</li></ul><p>으로 검색하여 들어오신 분에게 도움이 되었으면 합니다!</p><a id="more"></a><h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>이때까지 Logstash 를 사용하면서 기본 input, filter, output 플러그인들만 사용했었는데<br>급하게 특정 필드의 암호화/복호화가 필요하여 구글링결과 Java filter plugin 라는 것을 찾았다.</p><p>해당 플러그인을 통해 아래와 같이 input 으로 들어온 특정 필드를 내가 만든 Java 코드를 통해 변환시킬 수 있다.</p><figure class="highlight js"><figcaption><span>Java filter plugin 을 통해 개발한 custom 암복호화 filter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    my_decrypt_plugin &#123;</span><br><span class="line">        source =&gt; <span class="string">"encrypted_field"</span></span><br><span class="line">        key =&gt; <span class="string">"password"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이 문서에서는 Docs의 예제 코드를 plugin으로 만들때 발생하는 <code>에러 해결방법</code>을 설명합니다.</p><h1 id="Java-filter-plugin"><a href="#Java-filter-plugin" class="headerlink" title="Java filter plugin"></a>Java filter plugin</h1><p>전체적인 방식은 <a href="https://www.elastic.co/guide/en/logstash/current/java-filter-plugin.html#java-filter-plugin">How to write a Java filter plugin</a> 에 잘 나와있지만,<br>해당 내용대로 진행시 (특정 Logstash 버전에서는) 몇가지 에러가 발생한다..</p><h2 id="Logstash-다운로드"><a href="#Logstash-다운로드" class="headerlink" title="Logstash 다운로드"></a>Logstash 다운로드</h2><p>다음 방법 중 환경에 맞게 Logstash 를 다운로드<br><a href="https://www.elastic.co/kr/downloads/logstash">Elastic - Download Logstash</a></p><figure class="highlight shell"><figcaption><span>Logstash 버전 확인</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/logstash --version</span></span><br><span class="line">Using bundled JDK: /usr/share/logstash/jdk</span><br><span class="line">logstash 7.11.2</span><br></pre></td></tr></table></figure><h2 id="Logstash-core-가-있어야-filter-plugin-빌드-가능"><a href="#Logstash-core-가-있어야-filter-plugin-빌드-가능" class="headerlink" title="Logstash-core 가 있어야 filter-plugin 빌드 가능"></a>Logstash-core 가 있어야 filter-plugin 빌드 가능</h2><figure class="highlight bash"><figcaption><span>Logstash-core compile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 나에게 맞는 버전의 &lt;branch_name&gt; 으로 다운</span></span><br><span class="line"><span class="comment"># git clone --branch &lt;branch_name&gt; --single-branch https://github.com/elastic/logstash.git &lt;target_folder&gt;</span></span><br><span class="line"><span class="built_in">cd</span> ~/mywork</span><br><span class="line">mkdir logstash_core</span><br><span class="line"><span class="built_in">cd</span> logstash_core</span><br><span class="line">git <span class="built_in">clone</span> --branch 7.11 --single-branch https://github.com/elastic/logstash.git .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 빌드</span></span><br><span class="line">./gradlew assemble</span><br><span class="line"></span><br><span class="line"><span class="comment"># core 빌드 확인</span></span><br><span class="line">ll logstash-core/build/libs/</span><br><span class="line">-rw-r--r-- 1 root root 1349807 Feb 26 02:52 logstash-core-7.11.2-javadoc.jar</span><br><span class="line">-rw-r--r-- 1 root root  437112 Feb 26 02:52 logstash-core-7.11.2-sources.jar</span><br><span class="line">-rw-r--r-- 1 root root  645893 Feb 26 02:52 logstash-core-7.11.2.jar</span><br></pre></td></tr></table></figure><h2 id="logstash-filter-java-예제코드-다운로드"><a href="#logstash-filter-java-예제코드-다운로드" class="headerlink" title="logstash-filter-java 예제코드 다운로드"></a>logstash-filter-java 예제코드 다운로드</h2><figure class="highlight bash"><figcaption><span>logstash-filter-java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/mywork</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/logstash-plugins/logstash-filter-java_filter_example</span><br><span class="line"></span><br><span class="line"><span class="comment"># elastic Docs에 있는대로 gradle.properties 만들어서 한줄추가</span></span><br><span class="line"><span class="comment"># LOGSTASH_CORE_PATH=/root/mywork/logstash_core/logstash-core/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Docs 의 내용대로 다운받은 Java 코드를 원하는 필터의 형태로 수정해준다.</span></span><br></pre></td></tr></table></figure><h2 id="에러발생"><a href="#에러발생" class="headerlink" title="에러발생"></a>에러발생</h2><p>이제 <a href="https://www.elastic.co/guide/en/logstash/current/java-filter-plugin.html#_running_the_gradle_packaging_task_3">이 내용</a>대로 예제코드들을 gem으로 만들려고 <code>./gradlew gem</code> 하면 에러 발생</p><h3 id="첫번째-에러"><a href="#첫번째-에러" class="headerlink" title="첫번째 에러"></a>첫번째 에러</h3><figure class="highlight bash"><figcaption><span>첫번째 에러</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line">** Where:*</span><br><span class="line">Build file <span class="string">'/root/mywork/logstash-filter-java_filter_example/build.gradle'</span> line: 102</span><br><span class="line">** What went wrong:*</span><br><span class="line"></span><br><span class="line">A problem occurred configuring root project <span class="string">'logstash-filter-java_filter_example'</span>.</span><br><span class="line">&gt; Could not create task <span class="string">':gem'</span>.</span><br><span class="line">&gt; No signature of method: org.gradle.api.internal.tasks.DefaultTaskDependency<span class="variable">$TaskDependencySet</span>.getAt() is applicable <span class="keyword">for</span> argument types: (ArrayList) values: [[task <span class="string">':downloadAndInstallJRuby'</span>, task <span class="string">':removeObsoleteJars'</span>, ...]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... blah-blah </span></span><br></pre></td></tr></table></figure><p>구글링결과 위와 같은 에러는 많은 글이 있었다.<br>출처: <a href="https://discuss.elastic.co/t/logstash-java-filter-plugin-example-gradlew-gem-error/257110">https://discuss.elastic.co/t/logstash-java-filter-plugin-example-gradlew-gem-error/257110</a><br>의 내용대로 <code>build.gradle</code> 을 수정</p><figure class="highlight js"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependsOn [downloadAndInstallJRuby, removeObsoleteJars, vendor, generateRubySupportFiles]</span><br><span class="line">을</span><br><span class="line">dependsOn ([downloadAndInstallJRuby, removeObsoleteJars, vendor, generateRubySupportFiles])</span><br><span class="line">으로 수정시 에러 해결</span><br></pre></td></tr></table></figure><h3 id="두번째-에러"><a href="#두번째-에러" class="headerlink" title="두번째 에러"></a>두번째 에러</h3><figure class="highlight bash"><figcaption><span>두번째 에러</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: package co.elastic.logstash.api does not exist</span><br><span class="line">import co.elastic.logstash.api.Configuration;</span><br><span class="line">                              ^</span><br></pre></td></tr></table></figure><p>패키지를 못찾는 에러 발생<br>여기저기 구글링 중 결국 중국 블로그에서 해결책을 찾았다.<br>출처: <a href="https://www.cnblogs.com/shiqi17/p/14168550.html">https://www.cnblogs.com/shiqi17/p/14168550.html</a></p><figure class="highlight bash"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation fileTree(dir: LOGSTASH_CORE_PATH, include: <span class="string">"**/logstash-core-?.?.?.jar"</span>)</span><br><span class="line">을</span><br><span class="line">implementation fileTree(dir: LOGSTASH_CORE_PATH, include: <span class="string">"**/logstash-core-?.??.?.jar"</span>)</span><br><span class="line">으로 수정시 에러 해결</span><br></pre></td></tr></table></figure><p>원인은 내가 받은 Logstash의 마이너 버전이 7.11.2 으로 두자리 숫자라 제대로 맵핑이 안되서 발생된 것이었다.<br><code>Logstash 의 버전을 확인하여 마이너 버전이 두자리일 경우에만 build.gradle 의 위 코드 ?.?.? 을 ?.??.? 으로 수정 하면 됩니다.</code></p><h2 id="gem-으로-빌드된-custom-plugin을-Logstash에-설치"><a href="#gem-으로-빌드된-custom-plugin을-Logstash에-설치" class="headerlink" title="gem 으로 빌드된 custom plugin을 Logstash에 설치"></a>gem 으로 빌드된 custom plugin을 Logstash에 설치</h2><figure class="highlight bash"><figcaption><span>Java filter plugin install</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bin/logstash-plugin install --no-verify --<span class="built_in">local</span> /root/mywork/logstash-filter-java_filter_example/logstash-filter-java_filter_example-1.0.2.gem</span><br><span class="line">...</span><br><span class="line">Installing logstash-filter-java_filter_example</span><br><span class="line">Installation successful</span><br></pre></td></tr></table></figure><h2 id="설치한-플러그인-실행"><a href="#설치한-플러그인-실행" class="headerlink" title="설치한 플러그인 실행"></a>설치한 플러그인 실행</h2><figure class="highlight bash"><figcaption><span>example plugin test</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat java_filter.conf</span><br><span class="line">input &#123;</span><br><span class="line">  generator &#123; message =&gt; <span class="string">"Hello world!"</span> count =&gt; 1 &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  java_filter_example &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ bin/logstash -f ./java_filter.conf</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">       <span class="string">"message"</span> =&gt; <span class="string">"!dlrow olleH"</span>,</span><br><span class="line">      <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">    <span class="string">"@timestamp"</span> =&gt; 2021-02-26T04:05:27.633Z,</span><br><span class="line">          <span class="string">"host"</span> =&gt; <span class="string">"host"</span>,</span><br><span class="line">      <span class="string">"sequence"</span> =&gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://datahack.dev/2021/03/11/data/elastic/logstash-java-filter-plugin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>pip(Pypi) 미러서버 설정</title>
      <link>https://datahack.dev/2020/04/19/etc/pip-mirror/</link>
      <guid>https://datahack.dev/2020/04/19/etc/pip-mirror/</guid>
      <pubDate>Sun, 19 Apr 2020 12:23:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;데이터분석 공부를 위해 셋팅해둔 docker 이미지(jupyter)를 오랜만에 다시 build 하니 tensorflow 패키지 다운로드가 너무 오래 걸려서 build가 timeout이 되었다.&lt;br&gt;Pypi(pip)의 mirror 설정으로 변경 후 다시 실행하니 바로 해결!&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>데이터분석 공부를 위해 셋팅해둔 docker 이미지(jupyter)를 오랜만에 다시 build 하니 tensorflow 패키지 다운로드가 너무 오래 걸려서 build가 timeout이 되었다.<br>Pypi(pip)의 mirror 설정으로 변경 후 다시 실행하니 바로 해결!</p><a id="more"></a><p>mirror 서버 설정은 아래와 같이 <code>~/.pip/pip.conf</code>을 국내 서버로 설정</p><figure class="highlight js"><figcaption><span>~/.pip/pip.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url=http:<span class="comment">//ftp.daumkakao.com/pypi/simple</span></span><br><span class="line">trusted-host=ftp.daumkakao.com</span><br></pre></td></tr></table></figure><p>Dockerfile의 경우 아래와 같이 <code>.pip</code> 디렉토리 생성후 동일한 설정</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir ~/.pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">printf</span> <span class="string">"[global]\nindex-url=http://ftp.daumkakao.com/pypi/simple\ntrusted-host=ftp.daumkakao.com"</span> &gt; ~/.pip/pip.conf</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://datahack.dev/2020/04/19/etc/pip-mirror/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Github page 블로그 시작 (hexo icarus 설정)</title>
      <link>https://datahack.dev/2020/04/18/etc/hexo-blog/</link>
      <guid>https://datahack.dev/2020/04/18/etc/hexo-blog/</guid>
      <pubDate>Sat, 18 Apr 2020 02:15:59 GMT</pubDate>
      <description>
      
        &lt;p&gt;예전부터 미뤄왔던 블로그를 이제서야 시작해본다.&lt;br&gt;첫글은 hexo icarus 테마 중 내가 몇가지 수정한 것을 포스팅&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한글 font 변경&lt;/li&gt;
&lt;li&gt;profile 변경&lt;/li&gt;
&lt;li&gt;article 가독성을 위해 변경&lt;/li&gt;
&lt;li&gt;그 외에도 몇가지 (방문자수 등)&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>예전부터 미뤄왔던 블로그를 이제서야 시작해본다.<br>첫글은 hexo icarus 테마 중 내가 몇가지 수정한 것을 포스팅</p><ul><li>한글 font 변경</li><li>profile 변경</li><li>article 가독성을 위해 변경</li><li>그 외에도 몇가지 (방문자수 등)</li></ul><a id="more"></a><h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>hexo 관련 구글링을 하다보면 거의 <code>모든 hexo 블로그의 시작 포스팅은 이 hexo 설정글</code>이다.<br>hexo 설치나 기본 포스팅 방법들은 구글링하면 잘 정리해둔 블로그들이 엄청 많으니 생략하고,<br>나도 그 설정글 작성에 동참을 해보기 위해 몇가지 내가 수정한 사항들만 포스팅해본다.</p><blockquote><p>수정한 내용 중 틀린부분이 있을 수 있습니다.<br>혹시 틀린부분이나 더 정확한 수정방법이 있으면 댓글 남겨주세요.</p></blockquote><h1 id="icarus-설정"><a href="#icarus-설정" class="headerlink" title="icarus 설정"></a>icarus 설정</h1><p><a href="https://github.com/ppoffice/hexo-theme-icarus/releases/tag/3.0.0">icarus 릴리즈노트</a>를 보면 3.0 대로 버전이 올라가면서 레이아웃이 <code>JSX</code>과 <code>Inferno.js</code>으로 모두 변경되었다고 한다.<br>icarus 설정글 구글링시 대부분 기존 html 템플릿 엔진인 ejs를 기준으로 작성된 블로그가 대부분이다..<br>프론트엔드쪽을 많이 본적은 없지만 jsx 문법은 꽤나 직관적인것 같다. 아직은 몇가지 스타일만 변경하였는데 jsx도 조금씩 수정해봐야겠다.</p><blockquote><p>이 글은 icarus 3.0.0 버전을 기준으로 작성합니다.</p></blockquote><h2 id="한글-font-변경"><a href="#한글-font-변경" class="headerlink" title="한글 font 변경"></a>한글 font 변경</h2><p>icarus 기본 한글 글씨체도 나쁘지 않았지만, <a href="https://hangeul.naver.com/2017/nanum">나눔스퀘어라운드</a> 폰트를 사용하기로 했다.</p><ol><li><p>폰트 cdn import<br>아래 cdn 주소를 import 해준다.</p><figure class="highlight js"><figcaption><span>themes/icarus/source/css/default.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(https:<span class="comment">//cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css)</span></span><br></pre></td></tr></table></figure></li><li><p>폰트 지정<br>기존 <code>$family-sans-serif</code> 라인을 주석처리 한뒤, 아래처럼 지정한다.</p><figure class="highlight js"><figcaption><span>themes/icarus/include/style/base.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $family-sans-serif ?= Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif</span></span><br><span class="line">$family-sans-serif ?= <span class="string">'NanumSquareRound'</span>, <span class="string">"Helvetica Neue"</span>, sans-serif</span><br></pre></td></tr></table></figure></li></ol><h2 id="profile-변경"><a href="#profile-변경" class="headerlink" title="profile 변경"></a>profile 변경</h2><p>기존 profile 위젯의 하단은 무조건 follow 라는 github 링크 버튼이 따라다니는데, 뭔가 테마에 맞지 않는 파란색으로 느껴졌다. 그리고 포스팅 내용을 본 뒤 home으로 가는 버튼이 있으면 좋을것 같아 해당 위치의 버튼을 home 버튼기능으로 변경하고, 디자인도 변경하였다.</p><p>icarus 테마는 <code>Bulma</code>라는 CSS 프레임웍을 사용한다.<br><a href="https://bulma.io/documentation/elements/button/#styles">https://bulma.io/documentation/elements/button/#styles</a> 에서 다양한 버튼이 확인 가능하다.<br><img src="bulma_button.png" alt="다양한 버튼 스타일"></p><p><code>themes/icarus/layout/widget/profile.jsx</code>을 보면 기존 followLink 코드를 볼 수 있다.</p><figure class="highlight jsx"><figcaption><span>themes/icarus/layout/widget/profile.jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;followLink ? <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"level"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"level-item button is-primary is-rounded"</span> <span class="attr">href</span>=<span class="string">&#123;followLink&#125;</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span>&gt;</span>&#123;followTitle&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><p>github follow 기능을 유지하고 버튼 스타일만 변경할 경우 위 코드의 class 부분을 <code>bulma</code> 링크에서 고른 원하는 스타일로 <strong>예) “level-item button is-info is-outlined is-rounded”</strong> 으로 변경 하면 되고, 기능도 home으로 변경하려면 기존의 위 코드를 주석 처리하고 아래의 코드를 넣어준다.</p><p>아래 코드로 변경하면 profile widget의 followLink가 아닌 홈(“/“) 경로로 static하게 고정된다.</p><figure class="highlight jsx"><figcaption><span>themes/icarus/layout/widget/profile.jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"level"</span>&gt;</span><br><span class="line">&lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"level-item button is-info is-outlined is-rounded"</span> href=<span class="string">"/"</span> target=<span class="string">"_self"</span> rel=<span class="string">"noopener"</span>&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h2 id="article-가독성을-위해-변경"><a href="#article-가독성을-위해-변경" class="headerlink" title="article 가독성을 위해 변경"></a>article 가독성을 위해 변경</h2><p>포스팅의 가독성은 <a href="https://louisbarranqueiro.github.io/hexo-theme-tranquilpeak/">hexo Tranquilpeak 테마</a>의 스타일이 좋은것 같았다. 해당 스타일의 css을 참고하여 나의 입맛에 맞추어 수정 하였다.</p><ol><li><p>포스트 제목 폰트 변경 (<code>&amp;.article</code> 밑 <code>.title</code>이 없을텐데 2~5줄 코드를 추가)</p><figure class="highlight js"><figcaption><span>themes/icarus/include/style/article.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;.article</span><br><span class="line">    .title</span><br><span class="line">        font-size: <span class="number">2.0</span>em</span><br><span class="line">        font-weight: <span class="number">700</span></span><br><span class="line">        letter-spacing: <span class="number">-1.4</span>px;</span><br></pre></td></tr></table></figure></li><li><p>포스트 내용 폰트 변경 (<code>.content 내용을 아래와 같이 수정/추가</code>)</p><figure class="highlight js"><figcaption><span>themes/icarus/include/style/article.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.content</span><br><span class="line">    font-size: $article-font-size</span><br><span class="line">    line-height: <span class="number">1.9</span>em;</span><br><span class="line">    letter-spacing: <span class="number">-0.3</span>px;</span><br><span class="line">    color: #5d686f;</span><br><span class="line">    margin-top: <span class="number">20</span>px;</span><br></pre></td></tr></table></figure></li><li><p>heading 폰트 변경 (<code>h1</code>과 <code>h2</code> 수정)<br>heading 간격이 너무 붙어 있어서 조금 벌리고, h1, h2 폰트사이즈도 큰 차이가 없는것 같아서 수정</p><figure class="highlight js"><figcaption><span>themes/icarus/include/style/article.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h1</span><br><span class="line">    font-size: <span class="number">1.95</span>em</span><br><span class="line">    font-weight: <span class="number">600</span></span><br><span class="line">    margin-top: <span class="number">50</span>px;</span><br><span class="line"></span><br><span class="line">h2</span><br><span class="line">    font-size: <span class="number">1.5</span>em</span><br><span class="line">    margin-top: <span class="number">35</span>px;</span><br></pre></td></tr></table></figure></li><li><p>columns 사이즈 변경<br>widescreen일 경우 포스팅내용의 좌우폭을 늘림, <a href="https://bulma.io/documentation/columns/sizes/#12-columns-system">bulma의 columns 사이즈</a>를 참고하여 기본 layout 사이즈를 1 높였다.</p><blockquote><p>메뉴얼을 보면 항상 12 columns 를 맞추게 되어있는데 내 블로그의 경우 블로그 내용을 볼때는 위젯을 우측 한줄만 사용함으로 사이즈를 1 높이면, widgets.jsx 을 1 줄여야 할것 같은데 생각보다 위젯이 너무 좁아보여서 그냥 포스팅 내용 폭만 늘렸다. (css를 잘몰라서 사용해보다가 이상한 부분이있으면 다시 조정해야겠다.)</p><p>내 블로그는 <code>글을 눌러서 볼때</code> columnsCount 가 2줄이므로 아래 7번째줄 코드만 <code>is-9-widescreen</code>으로 사이즈 1증가</p></blockquote><figure class="highlight jsx"><figcaption><span>themes/icarus/layout/layout.jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"columns"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=&#123;classname(&#123;</span><br><span class="line">        column: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'order-2'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'column-main'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'is-12'</span>: columnCount === <span class="number">1</span>,</span><br><span class="line">        <span class="string">'is-8-tablet is-8-desktop is-9-widescreen'</span>: columnCount === <span class="number">2</span>,</span><br><span class="line">        <span class="string">'is-8-tablet is-8-desktop is-6-widescreen'</span>: columnCount === <span class="number">3</span></span><br><span class="line">    &#125;)&#125; dangerouslySetInnerHTML=&#123; <span class="attr">__html</span>: body &#125;&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Widgets site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; position=&#123;'left'&#125; /</span>&gt;</span><br><span class="line">    &lt;Widgets site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; position=&#123;<span class="string">'right'</span>&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="그-외에도-몇가지"><a href="#그-외에도-몇가지" class="headerlink" title="그 외에도 몇가지"></a>그 외에도 몇가지</h2><p>그외에도 이것저것 수정을 했는데 다 기억이 나지 않는다..<br>혹시 필요한 부분이 있다면 댓글 부탁드립니다.</p><ul><li>logo image 크기 늘림</li><li>navbar 의 메뉴간 사이 변경</li><li>Google Analytics는 계정생성 후 <code>themes/icarus/_config.yml</code> 에 <code>tracking_id</code> 추가시 적용 됨.</li><li>포스팅별 읽은 수 및 footer에 나오는 총 방문자는 <code>busuanzi: true</code> 만 적용하니 잘 적용 됨.<ul><li>덴마크어 yml만 적용되어있어서 처음 변경시 덴마크어로 나오는데, <code>themes/icarus/languages/ko.yml</code>에 <code>plugin: visit:</code>과 <code>visitor:</code> 추가하여 한글추가</li></ul></li><li>등</li></ul><p>끝.</p>]]></content:encoded>
      
      <comments>https://datahack.dev/2020/04/18/etc/hexo-blog/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
